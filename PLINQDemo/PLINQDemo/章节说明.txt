PLIN简介

.NET Framework 中有个子集叫并行库。通常被称作 "并行框架扩展" (Parallel Framework Extensions)  简称PFX,这是这些并行库非常早期的版本名称，并行库跟着.NET Framework 4.0一起发布，包含三大主要部分:
1.任务并行库(TPL)
2.并发集合
3.并行LINQ或(PLINQ)

  事实上我们将程序分割成一组任务并使不同的线程来运行不同的任务。这种任务被称为任务并行(Task Parallelism)
  想象一下我们有一个程序针对一组大数据进行重量级运算。并行运行该程序最简单的方式是将该组数据分割成较小的数据块，对这些数据块进行并行
计算,然后聚合这些计算结果，这种编程模型被称为数据并行(data Parallelism)
  
  任务并行是最底层的抽象层，我们将程序定义为任务的组合，显式的定义这些任务如何组合。由此方式组成的任务会非常复杂和细节化。并行操作被
定义在该程序的不同位置，随着并行操作的增长，程序变得越来越难理解和维护。采用这种方式来并行程序被称为 “无结构的并行” 这就是我们为复杂
的并行逻辑付出的代价。

  然而，当我们有较为简单的程序逻辑时，我们可以将更多的并行细节退给PFX和C#编译器。例如 我们可以说 "我想以并行的方式运行这三个程序，但是
我不关心是如何实现并运行的，让.	net基础设施决定细节" ，这产生了一个抽象层使得我们不用提供一个关于如何实现并行的细节描述。这种方式被称为
结构并行。因为并行通常是一组声明，并且在程序中每个并行情况定义在确切的地方

  (这可能导致一种印象，即无结构并行是一种不好的实践，应该始终使用结构并行来代替它，这一点是不对的。结构化并行确实容易维护，应该尽可能使
用，但是他并不是万能的。通常有很多情况我们不能简单地使用结构并行，那么以非结构化并行的方式使用TPL任务并行也是完全可以的)

  任务并行库中有一个Parallel的类，其提供了一组API来实现结构并行。他仍然是TPL的一部分，它是从较低的抽象层向较高的抽象层过滤的完美例子。
当使用Parallel的API时，我们无需提供分割工作的细节，但是我们仍要显式定义如何从分割的结果得到单个结果

  PLINQ具有最高抽象。它将自动将数据分割为数据块，并且决定是否真的需要并行化查询，或者使用通常的顺序查询处理更高效。PLINQ基础设施会将分
割任务的执行结果组合到一起。有很多选项可提供程序来优化查询，使用尽可能的性能获取结果